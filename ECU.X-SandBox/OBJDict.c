/*!
** @file   ObjDict.c
** @author CAN Festival
** @date   OD File produced: 2011-05-21 12:20:34.445000
**
** @brief This file is generated by the Object Dictionary Editor, as 
** originally developed by CAN Festival and modified by JDCC. 
** Specific contents are detailed in Object Dictionary Template.
** Editor modification: 1/29/2017 -- rev 2.0.0 
**
** 
*/  

/*This object dictionary file should only be modified by the Object Dictionary Editor */
#include "ObjDict.h"
#include <string.h>
#include <stddef.h>



#define RW     0x00  
#define WO     0x01
#define RO     0x02

/**************************************************************************/
/* Declaration of mapped variables                                        */
/**************************************************************************/

int SensorAnalog_DifferentialDataCh1 = 0x00;
int SensorAnalog_DifferentialDataCh2 = 0x00;
//char  SensorSw = 0x00;
int SensorAnalog_SingleDataCh1 = 0x00;
int SensorAnalog_SingleDataCh2 = 0x00;
int SensorAnalog_Data_HPInCh1 = 0x00;
int SensorAnalog_Data_HPInCh2 = 0x00;
char SIBFault = 0x00;
char Fault_SIBFault = 0x00;
char Fault_SensorValueFault = 0x00;
char Fault_HighPowerFault = 0x00;
char SensorAttr_SensorFiltering = 0x00;
char SensorAttr_SensorSampleRate = 0x00;
char SensorAttr_SensorType = 0x00;


typedef struct td_subindex
{
   // char                    bAccessType;
   // char                    bDataType; /* Defines of what datatype the entry is */
   // long                    size;      /* The size (in Byte) of the variable */
    void*                   pObject;   /* This is the pointer of the Variable */
} subindex;

/** Struct for creating entries in the communictaion profile
 */
typedef struct td_indextable
{
    subindex*   pSubindex;   /* Pointer to the subindex */
    char   bSubCount;   /* the count of valid entries for this subindex
                         * This count here defines how many memory has been
                         * allocated. this memory does not have to be used.
                         */
    int   index;
} indextable;

/**************************************************************************/
/* The node id                                                            */
/**************************************************************************/
/* node_id default value.*/
char ObjDict_bDeviceNodeId = 0x04;

/**************************************************************************/
/* Array of message processing information */

const char ObjDict_iam_a_slave = 1;

/*
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

                               OBJECT DICTIONARY

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
*/

/* index 0x3003 :   Server Control Parameter. */
                    char ObjDict_highestSubIndex_obj3002 = 3; /* number of subindex - 1*/
                    const subindex ObjDict_Index3002[] = 
                     {
					   { (void*)&ObjDict_highestSubIndex_obj3002 },
                       { (void*)&SensorAttr_SensorFiltering},
                       { (void*)&SensorAttr_SensorSampleRate},
					   { (void*)&SensorAttr_SensorType},
                     };	
					 
/* index 0x3003 :   Server Control Parameter. */
                    char ObjDict_highestSubIndex_obj3003 = 3; /* number of subindex - 1*/
                    const subindex ObjDict_Index3003[] = 
                     {
					   { (void*)&ObjDict_highestSubIndex_obj3003 },
                       { (void*)&Fault_SensorValueFault},
                       { (void*)&Fault_SIBFault},
					   { (void*)&SIBFault},
                     };					 

/**************************************************************************/
/* Declaration of variables                                       */
/**************************************************************************/

const indextable ObjDict_objdict[] = 
{
  { (subindex*)ObjDict_Index3002,sizeof(ObjDict_Index3002)/sizeof(ObjDict_Index3002[0]), 0x3002},
  { (subindex*)ObjDict_Index3003,sizeof(ObjDict_Index3003)/sizeof(ObjDict_Index3003[0]), 0x3003}  
};

const indextable * ObjDict_scanIndexOD (int wIndex, float * errorCode)
{
	int i;
	switch(wIndex)
        {
		case 0x1000: i = 0;break;
        case 0x1001: i = 1;break;
        case 0x1003: i = 2;break;
		case 0x1005: i = 3;break;
		case 0x1006: i = 4;break;
		case 0x1008: i = 5;break;
		case 0x1018: i = 6;break;
        case 0x2000: i = 7;break;
		case 0x2001: i = 8;break;		
		case 0x2003: i = 9;break;
		case 0x2004: i = 10;break;
		case 0x2010: i = 11;break;
		case 0x2011: i = 12;break;
        case 0x2020: i = 13;break;
        case 0x2500: i = 14;break;
		case 0x2900: i = 15;break;
		case 0x3000: i = 16;break;
        case 0x3001: i = 17;break;
        case 0x3002: i = 18;break;
        case 0x3003: i = 19;break;
        
		default:
			*errorCode = 0xFA;//OD_NO_SUCH_OBJECT;
			return NULL;
	}
	*errorCode = 0xFF; //OD_SUCCESSFUL;
	return &ObjDict_objdict[i];
}

/* 
 * To count at which received SYNC a PDO must be sent.
 * Even if no pdoTransmit are defined, at least one entry is computed
 * for compilations issues.
 * MUST BE EQUAL TO NUMBER IN INDEX
 */

const int ObjDict_ObjdictSize = sizeof(ObjDict_objdict)/sizeof(ObjDict_objdict[0]); 

//CO_Data ObjDict_Data = NODE_DATA_INITIALIZER(ObjDict); // prepends "ObjDict" to definitions

